# chatGPT를 이용한 프로젝트 README.md 파일 작성방법
프로젝트 POC를 구성하거나 프로젝트 과제를 진행할때 제출해야하는 부분이 README.md 파일입니다.

프로젝트에 대한 전체적인 메뉴얼을 만드는 느낌으로 써야되는데 
메뉴얼처럼 써내려간다는게 쉬운것이 아니라서 많은 부분 어떻게 써야하는지 고심하는 부분입니다 
<br/><br/><br/>

# 메뉴얼 작성하는 방법
### 1.독자층 정의하기
독자를 알아야 합니다 - 그들의 경험 수준은 어떤가요? 매뉴얼을 읽는 장소는 어디인가요? - 그리고 그들의 전문성에 맞게 지침을 최적화하세요. 문서화 작업을 공동으로 수행하는 팀의 일부인 경우 독자의 프로필을 작성하는 것이 도움이 될 수 있습니다.
<br/><br/>
### 2.문제 설명하기
해결하고자 하는 문제를 설명하고, 해결책을 제시한 다음, 해당 솔루션을 얻기 위한 지침을 개요로 제시하세요. 당연한 얘기처럼 들릴 수 있지만, 이것은 어떤 우수한 사용자 매뉴얼의 기본 구성 요소입니다.
<br/><br/>
### 3.세분화하기
매뉴얼에서 다루는 문제가 특히 복잡한 경우, 이를 더 작은 부분으로 나누어서 설명하세요. 각 섹션에 구체적인 지침을 나열하세요. 이렇게 정보를 세분화함으로써, 문제를 해결하기 쉽고 따라가기 쉽게 만들 수 있습니다.
<br/><br/>
### 4.구체적으로 서술하기
"것", "부분", "물건"과 같은 애매한 단어는 모호한 지시사항으로 이어집니다. 무엇인지 모를 경우 온라인에서 찾아보거나 누군가에게 물어보는 등 최선을 다해 그것을 식별하세요. 한 단계를 완료하기 위해서는 몇 가지 복잡한 부품이 필요할 수 있습니다. "이 것"이라고 부품을 부르는 것은 누구에게도 도움이 되지 않습니다.
<br/><br/>
### 5.핵심 주제에 집중하기
사람들은 여러분의 할머니가 아이스크림을 가방에 넣는 일화를 좋아하지만, 이야기를 전하는 적절한 장소가 있습니다. 지침서의 중간은 그런 이야기를 위한 곳이 아닙니다.
<br/><br/>
### 6.멋진 사진(혹은 더 나아가 비디오) 사용하기
사진은 사람들이 지침서를 찾게 하는 가장 중요한 요소입니다. 품질 좋은 사진을 찍기 위해서는 비싼 장비가 필요하지 않습니다 - 스마트폰이나 간단한 캡처 카메라를 사용할 수 있습니다. 더 좋은 사진을 찍는 간단한 팁은 "사진
<br/><br/>
### 7.수동태 피하기
지시사항을 직접적으로 전달하기 위해 수동태를 사용하지 마세요. 대신 동사를 사용하여 정확하게 전달하세요.
<br/><br/>
### 8.일인칭 표현 피하기
글에서 "나"는 없어야 합니다. 지시사항에서 "나는 이것을 했다"와 같은 문장을 사용하지 않음으로써 더 권위 있는 톤을 구사할 수 있습니다.
<br/><br/>
### 9.템플릿 사용하기
지침서를 표준화하는 것은 독자의 이해력과 명확성을 향상시키는 데 도움이 됩니다. 일관된 글머리 기호 스타일, 이미지 크기 및 텍스트 방향과 같은 요소들은 독자가 찾아보고 따라가기 쉽게 만들어줍니다. 지침서를 표준화하는 데 도움이 되는 프로그램을 찾고 있다면 Dozuki의 방식을 확인해보세요.
<br/><br/>
### 10.배경 정보 최소화하기
약간의 배경 정보는 좋습니다. 왜 이 작업을 하는지, 누가 가이드를 활용할 수 있는지, 사람들이 준비를 위해 무엇을 해야 하는지 등을 설명하는 것은 좋습니다. 하지만 그걸로 끝내야 합니다. 대부분의 사람들은 TV와 함께 제공된 전체 사용자 매뉴얼을 읽는 것을 꺼립니다.
사진을 통해 독자의 방향 파악하기
<br/><br/>
### 11.사진을 통해 독자의 방향 파악하기
사진을 찍을 때, 물체의 방향성을 최대한 일관되게 유지해야 합니다. 독자는 자신의 상대적인 위치를 더 쉽게 파악할 수 있을 것입니다. 물체를 회전시키는 경우, "장치를 뒤집으세요" 또는 "장치를 시계 방향으로 90도 회전하세요"와 같은 문장을 포함하여 독자도 동일하게 회전하고 따라갈 수 있도록 도와주세요.
<br/><br/>
### 12.단순하고 길지 않게 작성하기
사람들은 이해할 수 없는 지침서를 사용하지 않습니다. 마지막으로, 그것은 셰익스피어 작품이 아닙니다.

# chatGPT를 이용하는방법
예를들어 GITHUB에 사전과제용 프로젝트를 작업했다고 가정해보겠습니다.

https://github.com/lswteen/user


아래 첨부한 이미지는 제가 chatGPT나오기전에 여러 개발블로그, 프로젝트진행, 블로그 글을쓰면서 대략적인 메뉴얼을 누적된 지식을기반으로 작성했던 내용입니다.
고민도 많이하고 하루정도 꼬박 작업하면서 쉽지가 않다는 생각을 하게되었는데
chatGPT를 사용하면 기본적인 글쓰기에 뼈대를 단 1-2분만에 만들수 있습니다.

![스크린샷 2023-05-05 오후 9 31 53](https://user-images.githubusercontent.com/3292892/236458306-37a0028e-f648-4e46-9aae-c2e90bde6f09.png)

# chatGPT 프롬프트 만들어서 요청하기
Java+Springboot 프로젝트에서 
controller.java, build.gradle, application.yml 3개정도만 chatGPT에 입력하고 
프로젝트의 Readme.md 를 만들어달라고 표현하면됩니다.

해당 프로젝트는 java, Springboot, SpringSecurity사용하였습니다.
중요한 포인트는 스프링시큐리티를 이해하고 회원 로그인,로그아웃,인증에 대한부분을 처리하는 RestAPI입니다.

chatGPT 3.5버전에 물어보도록 하겠습니다.
최근 chatGPT를 사용하는 방법에서 프롬프트라는 개념이 중요하게 들어갑니다.
프롬프트는 chatGPT에 가장 적절한 질문을 정리해서 물어보는 방식입니다.


Readme.md 프롬프트
```shell
JAVA,Springboot,Security 로 작업한 스프링프레임워크 Restful API입니다.
회원에 대한 기능을 제공하고있습니다.

스프링 시큐리티와, 작업된 코드레벨에 아키텍처 를 도식화해서 readme.md를 구성하고싶습니다.
중요한포인트는 시큐리티의 라이프싸이클입니다. 

controller.java, build.gradle, application.yml 파일 3개를 첨부하겠습니다.
만약 더필요한 코드에 대한 구조를 첨부해야한다면 어떤것을 더넣어야하는지도 알려주세요 추가해보도록 하겠습니다.


build.gradle
plugins {
	id 'org.springframework.boot' version '2.5.6'
	id 'io.spring.dependency-management' version '1.0.11.RELEASE'
	id 'java'
}

group = 'com.renzo'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '11'

repositories {
	mavenCentral()
}

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-actuator'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	implementation 'org.springframework.boot:spring-boot-starter-security'
	implementation 'org.springframework.boot:spring-boot-starter-validation'


	implementation 'org.springframework.boot:spring-boot-starter-data-redis'

	compile("com.querydsl:querydsl-apt:4.4.0")
	compile("com.querydsl:querydsl-sql:4.4.0")
	compile("com.querydsl:querydsl-sql-spring:4.4.0")
	compile("com.querydsl:querydsl-jpa:4.4.0")
	runtimeOnly 'mysql:mysql-connector-java'
	implementation('com.h2database:h2:1.4.196')

	implementation 'io.jsonwebtoken:jjwt:0.9.1'

	compileOnly 'org.projectlombok:lombok'
	annotationProcessor 'org.projectlombok:lombok'

	compile group: 'com.google.code.gson', name: 'gson', version: '2.8.5'

	compile group: 'io.springfox', name: 'springfox-swagger2', version: '2.9.2'
	compile group: 'io.springfox', name: 'springfox-swagger-ui', version: '2.9.2'

	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testImplementation 'org.springframework.security:spring-security-test'

	// JUnit4
	testImplementation('org.junit.vintage:junit-vintage-engine') {
		exclude group: 'org.hancrest', module: 'hamcrest-core'
	}
}

def queryDslDir = "src/main/generated"
def queryDslOutput = file("${queryDslDir}")
sourceSets {
	main {
		java {
			srcDir queryDslDir
		}
	}
}

dependencies {
	implementation 'junit:junit:4.13.1'
	implementation 'junit:junit:4.13.1'
	compile "com.querydsl:querydsl-jpa:4.4.0"
	annotationProcessor(
			"com.querydsl:querydsl-apt:4.4.0:jpa"
			, "javax.annotation:javax.annotation-api:1.3.2"
			, "org.hibernate.javax.persistence:hibernate-jpa-2.1-api:1.0.2.Final"
	)
}

def gradleGeneratedDir = "./build/generated/source/apt"
def gradleQueryDslOutput = file("${gradleGeneratedDir}")

task cleanUpQueryDsl(type: Copy) {
	from "${gradleGeneratedDir}/main"
	into "${queryDslDir}"
	doLast {
		delete gradleQueryDslOutput
	}
}

compileJava.finalizedBy(cleanUpQueryDsl)

clean {
	delete gradleQueryDslOutput
	delete queryDslOutput
}


user controller 

package com.renzo.web;

import com.renzo.config.security.JwtTokenProvider;
import com.renzo.web.request.UserRequest;
import com.renzo.web.response.UserResponse;
import com.renzo.web.service.SmsCertificationService;
import com.renzo.web.service.UserAppService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import io.swagger.annotations.*;
import springfox.documentation.annotations.ApiIgnore;

import static com.renzo.web.response.ResponseConstants.CREATED;
import static com.renzo.web.response.ResponseConstants.OK;

@Slf4j
@RequestMapping("/api")
@RestController
@Api(tags = "회원")
@RequiredArgsConstructor
public class UserController {
    private final UserAppService userAppService;
    private final JwtTokenProvider jwtTokenProvider;
    private final SmsCertificationService smsCertificationService;

    @ApiOperation(value = "회원가입", notes = "회원가입", tags = "회원")
    @ApiResponses({
        @ApiResponse(code=200, message="회원가입 성공시 login 페이지 이동합니다."),
        @ApiResponse(code=409, message="닉네임,이메일,휴대폰 번호는 유일한 식별자입니다.")
    })
    @ApiParam(value = "email", required = true,example = "a@gmail.com")
    @PostMapping("/user/singup")
    public UserResponse signup(UserRequest request){
        return userAppService.save(request);
    }

    /**
     * 로그인
     * 식별 가능한 모든 정보로 로그인 가능
     * 식별 가능한 모든 정보가 무엇인지 스스로 판단하여 결정
     * 예) (아이디 혹인 전화번호) + 비밀번호 입력 하여 로그인 가능
     * @return
     */
    @ApiOperation(value = "로그인",
            produces = MediaType.APPLICATION_JSON_VALUE,
            notes = "로그인", tags = "회원",
            responseHeaders = {
                    @ResponseHeader(name = HttpHeaders.CONTENT_TYPE, description = MediaType.APPLICATION_JSON_VALUE)
            }
    )
    @PostMapping("/user/login")
    public String login(@RequestBody UserRequest.LoginRequest loginRequest){
        UserResponse userResponse = null;
        if(loginRequest.getType().equals("email")){
            userResponse = userAppService.emailLogin(loginRequest.getArgument(), loginRequest.getPassword());
        }else if(loginRequest.getType().equals("phone")){
            userResponse = userAppService.phoneLogin(loginRequest.getArgument(), loginRequest.getPassword());
        }else if(loginRequest.getType().equals("nickname")){
            userResponse = userAppService.nicknameLogin(loginRequest.getArgument(), loginRequest.getPassword());
        }

        return jwtTokenProvider.createToken(userResponse.getUsername(),userResponse.getRoles());
    }

    @ApiOperation(value = "회원정보보기",
            produces = MediaType.APPLICATION_JSON_VALUE,
            notes = "회원정보보기", tags = "회원",
            responseHeaders = {
                @ResponseHeader(name = HttpHeaders.CONTENT_TYPE, description = MediaType.APPLICATION_JSON_VALUE),
                @ResponseHeader(name = HttpHeaders.AUTHORIZATION, description = "X-AUTH-TOKEN JWT token")
            }
    )
    @PostMapping("/user/me")
    public UserResponse getMe(@ApiIgnore @AuthenticationPrincipal UserDetails userDetails){
        return userAppService.getUserByEmail(userDetails.getUsername());
    }

    /**
     * 로그인 되어있지 않은 상태에서 비밀번호 재설정 하는기능
     * 전화번호 인증 후 비밀번호 재설정이 가능해야함
     * @return
     */
    @ApiOperation(value = "비밀번호 찾기 (재설정)기능", notes = "비밀번호 찾기 (재설정)기능", tags = "회원")
    @PutMapping("/user/password")
    public ResponseEntity<Void> findByPasswordAndReset(String phonenumber, String newPassword){
        userAppService.findByPasswordAndReset(phonenumber,newPassword);
        return OK;
    }

    /**
     * 인증번호 발송
     * @param requestDto
     * @return
     */
    @PostMapping("/sms/certification/sends")
    @ApiOperation(value = "SMS 인증번호 발송", notes = "SMS 인증번호 발송", tags = "회원")
    public ResponseEntity<Void> sendSms(@RequestBody UserRequest.SmsCertificationRequest requestDto) {
        smsCertificationService.sendSms(requestDto.getPhone());
        return CREATED;
    }

    /**
     * 인증번호 확인
     * @param requestDto
     * @return
     */
    @ApiOperation(value = "SMS 인증번호 확인", notes = "SMS 인증번호 확인", tags = "회원")
    @PostMapping("/sms/certification/confirms")
    public ResponseEntity<Void> SmsVerification(@RequestBody UserRequest.SmsCertificationRequest requestDto) {
        smsCertificationService.verifySms(requestDto);
        return OK;
    }

}

application.yml 

server:
  port: 9030

spring:
  profiles:
    active: local

  application:
    name: user-service-api
    description: "SpringBoot JPA H2 Redis JWT Security User Service Api"

  jackson:
    time-zone: "Asia/Seoul"

  datasource:
    driverClassName: org.h2.Driver
    jdbcUrl: jdbc:h2:~/ably
    username: sa
    password:
    maximumPoolSize: 30
    minimumIdle: 5
    poolName: dbrenzo
    readOnly: false

  jpa:
    open-in-view: false
    hibernate:
      ddl-auto: create-drop
    properties:
      hibernate:
        show_sql: fase
        use_sql_comments: true
        format_sql: true
        dialect: org.hibernate.dialect.H2Dialect
  h2:
    console:
      path: /h2-console
      enabled: true

  redis:
    host: localhost
    port: 6379



Readme.md 스타일을 바로 붙여서 사용할수있게 부탁해여

```

chatGPT는 1 ~ 2분만에 readme.md에 부합하는 코드로 Response 해줍니다.

<img width="645" alt="스크린샷 2023-05-05 오후 9 46 56" src="https://user-images.githubusercontent.com/3292892/236461360-0c996a15-7505-4220-a953-b57b05d081d6.png">


```text
# 프로젝트명

프로젝트의 간략한 설명을 작성합니다.

## 시스템 아키텍처

![시스템 아키텍처 도식](architecture.png)

시스템 아키텍처를 설명하는 도식입니다. 이 도식은 시스템의 구성, 주요 컴포넌트 및 흐름을 보여줍니다.

## 기술 스택

프로젝트에서 사용된 기술 스택을 나열합니다.

- Java
- Spring Boot
- Spring Security
- 기타 등등...

## 시큐리티 라이프사이클

시큐리티 라이프사이클은 다음과 같은 단계로 이루어집니다:

1. 인증(Authentication): 사용자의 인증 정보를 확인하고 인증 객체를 생성합니다.
2. 권한 부여(Authorization): 인증된 사용자에게 권한을 부여합니다.
3. 인가(Authorization): 인증된 사용자가 특정 리소스에 접근할 수 있는지 확인합니다.
4. 보안 처리: 요청에 대한 보안 처리를 수행합니다.
5. 세션 관리: 세션을 관리하고 유지합니다.
6. 로깅 및 감사: 보안 관련 로그를 생성하고 감사합니다.

## 프로젝트 구조
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   ├── com.renzo/
│   │   │   │   ├── config/
│   │   │   │   ├── controller/
│   │   │   │   ├── model/
│   │   │   │   ├── repository/
│   │   │   │   ├── security/
│   │   │   │   ├── service/
│   │   │   │   ├── util/
│   │   │   │   └── Application.java
│   │   │   └── resources/
│   │   │      


프로젝트는 다음과 같은 구조를 갖고 있습니다:

security: 시큐리티 설정과 관련된 클래스가 포함됩니다.
service: 비즈니스 로직을 처리하는 서비스 클래스가 포함됩니다.
util: 유틸리티 클래스가 포함됩니다.
Application.java: 스프링 부트 애플리케이션의 진입점 클래스입니다.
application.yml: 애플리케이션의 설정 정보가 포함된 YAML 파일입니다.

## 사용법

프로젝트를 로컬 환경에서 실행하는 방법을 설명합니다.

Git 저장소에서 프로젝트를 클론합니다.
IDE에서 프로젝트를 엽니다.
application.yml 파일을 열고, 필요에 따라 설정을 수정합니다.
애플리케이션을 빌드하고 실행합니다.

```


어떤가요 chatGPT를 이용하면 프로젝트에 필요한 README.md 파일을 큰고민없이 기가막히게 만들어낼수 있습니다.
여기서 중요한건 프롬프트를 얼마나 잘 입력하는가입니다.

여러분도 정리하고싶은 프로젝트가 있다면 chatGPT를 활용해보세요