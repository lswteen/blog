# 면접준비하기

## WEB 적용방법
- 인터넷 네트워크 HTTP도 결국에는 TCP/IP나 UDP 기반 위에서 동작
- URI와 웹 브라우저 요청 흐름
URI와 URL의 개념을 확실하게 정리합니다.
웹 브라우저 요청 흐름을 통해 HTTP 메시지
TCP/IP 메시지 네트워크를 통해 목적지까지 도착하는지
HTML 응답을 받아와서 웹 브라우저에 렌더링 되는 과정
HTTP와 네트워크의 전체 사이클

### *URI And URL 차이*
```text
URI(Uniform Resource Identifier)와 URL(Uniform Resource Locator)는 인터넷에서 자원을 고유하게 식별하거나 위치를 지정하는 데 사용되는 문자열입니다. 이 두 개념은 서로 밀접하게 연관되어 있지만, 약간의 차이가 있습니다.

URI (Uniform Resource Identifier) : URI는 인터넷에서 특정 자원을 고유하게 식별하는 유일한 문자열입니다. 모든 URL은 URI이지만, 모든 URI가 URL은 아닙니다. 이는 왜냐하면 URI는 이름(name)과 위치(location) 둘 다를 나타낼 수 있지만, URL은 위치(location)만을 나타내기 때문입니다.
URL (Uniform Resource Locator) : URL은 인터넷에서 특정 자원의 위치를 나타내는 문자열입니다. URL은 자원이 어디에 위치하는지 그 위치를 나타냅니다. URL은 접근 프로토콜(http, https, ftp 등)과 자원의 위치(IP 주소 또는 도메인 이름)를 제공합니다.
예를 들어, "https://www.example.com/path/to/myfile.html"라는 문자열을 살펴보면, 이 문자열 전체는 URI입니다. 또한 이 문자열은 웹 서버(www.example.com)에서 특정 자원(/path/to/myfile.html)의 위치를 나타내므로 URL이기도 합니다. 즉, 이 예시에서는 URI와 URL이 동일한 문자열을 나타냅니다.  

그러나 "urn:isbn:0451450523" 같은 URI는 URL은 아닙니다. 이는 'urn' 스키마를 사용하여 국제 표준 도서 번호(ISBN)를 통해 책을 고유하게 식별합니다. 이 경우, URI는 자원을 고유하게 식별하지만 그 자원의 위치를 나타내지는 않습니다. 그래서 이는 URI이지만 URL은 아닙니다.
```

- HTTP 기본
**HTTP(Hypertext Transfer Protocol)**는 인터넷에서 데이터를 주고받을 수 있는 프로토콜입니다.  
웹 브라우저와 서버 간에 HTML 문서를 주고받을 때 주로 사용합니다.

```text
HTTP의 기본 동작  
HTTP는 클라이언트-서버 모델을 기반으로 동작합니다. 클라이언트(일반적으로 웹 브라우저)가 HTTP 요청을 서버에 보내면, 서버는 요청을 처리하고 결과를 HTTP 응답으로 클라이언트에게 반환합니다.  

HTTP는 여러 가지 요청 방식(Method)를 지원하는데, 가장 일반적인 방식은 GET과 POST입니다.  

GET: 정보를 요청합니다.
POST: 정보를 서버에 제출합니다.

HTTP의 기본 동작과 특징
상태유지(Stateful), 무상태(Stateless)개념과 HTTP 메시지

HTTP의 특징
HTTP는 상태를 유지하지 않는(stateless) 프로토콜입니다. 즉, 서버는 클라이언트의 이전 요청을 기억하지 않습니다. 이것이 HTTP의 가장 큰 특징이며, 각 요청이 독립적으로 간주되어 처리되는데, 이는 매 요청마다 새로운 연결이 생성되고, 요청이 처리된 후 연결이 바로 끊어진다는 것을 의미합니다.

그러나 이런 상태 유지하지 않는(stateless) 특성은 사용자의 세션을 유지하거나, 이전 요청과 이후 요청 사이의 관계를 유지하는 웹 애플리케이션에는 문제가 될 수 있습니다. 이러한 문제를 해결하기 위해 쿠키, 세션, 토큰 등의 기술이 도입되어 사용자의 상태를 일정 기간 동안 유지(stateful)할 수 있게 했습니다.

HTTP 메시지
HTTP 메시지는 요청 메시지와 응답 메시지 두 가지 형태가 있습니다. 각 메시지는 시작줄, 헤더, 본문으로 구성됩니다.

시작줄: 요청 또는 응답을 정의합니다. 요청 메시지에서는 HTTP 메소드와 요청 대상을, 응답 메시지에서는 상태 코드를 포함합니다.
헤더: 메시지의 메타데이터를 포함합니다. 콘텐츠의 유형, 전송 인코딩, 인증 정보 등을 포함할 수 있습니다.
본문: 전송할 실제 데이터를 포함합니다. 이 부분은 선택 사항이며, 데이터를 전송하지 않는 요청의 경우 생략될 수 있습니다.
```

- HTTP 메서드
GET, POST, PUT, PATCH, DELETE
```text
GET: 특정 리소스의 표시를 요청합니다. GET 요청은 오직 데이터를 가져오는 데 사용되어야 합니다.
POST: 특정 리소스를 서버에 제출하거나 저장하려 할 때 사용됩니다. 이는 종종 서버의 상태를 변경하거나 사이드 이펙트를 발생시킵니다.
PUT: 목적 리소스의 모든 현재 표시를 요청 페이로드로 바꿉니다. 즉, PUT은 리소스를 완전히 업데이트하는 데 사용됩니다.
PATCH: 리소스의 부분적인 수정을 수행합니다. PATCH 요청은 리소스에 대한 업데이트를 적용하되, PUT과 달리 전체 리소스를 변경하지 않고 리소스의 일부만 변경합니다.
DELETE: 특정 리소스를 제거합니다.
멱등성 GET , DELETE
-HTTP 상태코드
HTTP 상태코드 설명 어떤 상태코드를 주는게 올바른 방법인지 그리고 
2xx, 3xx, 4xx, 5xx의 제대로 된 의미와 사용법


- HTTP 헤더 - 일반 헤더
HTTP에는 수많은 헤더
여기서는 표현, 콘텐츠 협상, 전송 방식, 쿠키 등을 단순한 기능 설명이 아니라 예시와 사례

- HTTP 헤더 - 캐시
HTTP 캐시에 관한 기본 캐시가 필요한 이유부터 브라우저 캐시, 프록시 캐시, 조건부 요청, 캐시 무효화

- TCP3 way handshake

```



## 동시성 병렬성
```text
동시성(Concurrency): 동시성은 여러 작업이 동시에 발생하는 것처럼 보이는 것을 말합니다. 이는 작업들 사이에서 빠르게 전환함으로써 달성되며, 이를 멀티태스킹이라고도 합니다. 실제로는 한 번에 하나의 작업만 처리되지만, 작업 간 전환의 빠르기로 인해 동시에 처리되는 것처럼 느껴집니다. 예를 들어, 단일 코어 프로세서에서 여러 스레드를 실행하는 것은 동시성입니다.

병렬성(Parallelism): 병렬성은 실제로 여러 작업이 동시에 처리되는 것을 말합니다. 이는 여러 프로세서 코어 또는 컴퓨터를 사용하여 달성할 수 있습니다. 예를 들어, 멀티코어 프로세서에서 여러 스레드를 동시에 실행하는 것은 병렬성입니다.

이 두 가지 개념은 종종 혼동되지만, 서로 다른 문제를 해결합니다. 동시성은 일반적으로 I/O-bound 작업(예: 디스크 I/O 또는 네트워크 요청)에 유용하며, 병렬성은 CPU-bound 작업(예: 데이터 분석 또는 이미지 처리)에 유용합니다. 이 둘을 적절히 결합하여 효율적인 시스템을 구축할 수 있습니다.

```

## 동시성 (Concurrency) : 여러 스레드를 생성하고 관리하는 간단한 예입니다.
```java
class SimpleRunnable implements Runnable {
    public void run() {
        // 코드 실행
    }
}

public class ConcurrencyExample {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new SimpleRunnable());
        Thread thread2 = new Thread(new SimpleRunnable());

        thread1.start();
        thread2.start();
    }
}

위의 코드에서는 두 개의 스레드를 생성하고 시작합니다. 이 스레드들은 동시에 실행되지만, 실제로는 운영체제의 스케줄링에 따라 번갈아 가며 실행됩니다.
```


## 병렬성 (Parallelism) : Java 8의 Stream API를 사용하여 병렬 처리를 수행하는 예입니다.
```java
import java.util.Arrays;
import java.util.List;

public class ParallelismExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // 순차 스트림
        numbers.stream()
               .forEach(System.out::println);

        // 병렬 스트림
        numbers.parallelStream()
               .forEach(System.out::println);
    }
}

위의 코드에서는 순차 스트림과 병렬 스트림 두 가지를 사용하여 배열의 숫자를 출력합니다. 병렬 스트림은 여러 스레드에서 동시에 실행되므로 출력 순서가 예측할 수 없습니다. 반면, 순차 스트림은 단일 스레드에서 실행되므로 숫자가 순서대로 출력됩니다. 이러한 병렬 처리는 CPU-bound 작업에 유용하며, 대량의 데이터를 처리할 때 시간을 절약할 수 있습니다.
```

## 동기방식 비동기 방식 프로그래밍 사용되는 주요개념
### 동기 방식
```text
동기(Synchronous) 방식: 동기 방식에서는 한 작업이 완료될 때까지 기다렸다가 다음 작업을 실행합니다. 즉, 작업들이 순서대로 실행되며, 각 작업은 이전 작업이 완전히 완료된 후에 시작됩니다. 이렇게 함으로써 프로그램의 실행 흐름을 예측하기 쉽게 만들 수 있지만, 다른 작업을 기다리는 동안 프로그램이 멈추어 있어야 한다는 단점이 있습니다.

예를 들어, 웹 서버에 요청을 보내고 응답을 기다리는 과정에서, 서버의 응답을 기다리는 동안 애플리케이션은 다른 작업을 수행할 수 없습니다.
```
### 동기식 방식 코드 예시
이 동기식 코드 예시는 메인 스레드에서 순차적으로 메소드를 호출합니다. 각 메소드가 종료될 때까지 다음 메소드의 실행을 기다립니다.

```java
public class SynchronousExample {
    public static void main(String[] args) {
        printOne();
        printTwo();
    }

    public static void printOne() {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("One");
    }

    public static void printTwo() {
        System.out.println("Two");
    }
}

이 코드를 실행하면 "One"이 출력된 후 5초 동안 기다린 후에 "Two"가 출력됩니다.
```

### 동기방식 Springboot
 ```java
 @RestController
public class SynchronousController {

    @GetMapping("/sync")
    public String processSync() {
        return longRunningTask();
    }

    private String longRunningTask() {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "Task completed";
    }
}

이 코드에서 longRunningTask() 메소드는 5초 동안 sleep 상태에 머무르고, 이 메소드가 완료될 때까지 클라이언트는 응답을 기다려야 합니다.
 ```


### 비동기 방식
``` text
비동기(Asynchronous) 방식: 비동기 방식에서는 작업이 바로 완료될 필요가 없습니다. 즉, 한 작업이 완료되는 것을 기다리지 않고 바로 다음 작업을 시작할 수 있습니다. 이로 인해 프로그램이 더 효율적으로 동작할 수 있지만, 작업의 완료 순서를 예측하기 어렵고 따라서 복잡한 코드를 작성하게 될 수 있습니다.

예를 들어, 웹 서버에 여러 요청을 동시에 보내고, 각 요청이 완료되는대로 응답을 처리할 수 있습니다. 이렇게 하면 애플리케이션이 서버의 응답을 기다리는 동안도 다른 작업을 계속 수행할 수 있습니다.
```

### 비동기식 방식 코드 예시
이 비동기식 코드 예시는 메소드 호출을 별도의 스레드에서 실행합니다. 이렇게 하면 메인 스레드는 다른 작업을 계속할 수 있습니다.
```java
public class AsynchronousExample {
    public static void main(String[] args) {
        new Thread(() -> printOne()).start();
        new Thread(() -> printTwo()).start();
    }

    public static void printOne() {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("One");
    }

    public static void printTwo() {
        System.out.println("Two");
    }
}
이 코드를 실행하면 "Two"가 먼저 출력된 후, 5초 후에 "One"이 출력됩니다.

```

이 비동기식 코드 예시는 Spring의 @Async 어노테이션을 사용하여 별도의 스레드에서 메소드를 실행하고 CompletableFuture를 반환합니다.
 ```java
 @RestController
public class AsynchronousController {

    @Async
    @GetMapping("/async")
    public CompletableFuture<String> processAsync() {
        return CompletableFuture.completedFuture(longRunningTask());
    }

    private String longRunningTask() {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "Task completed";
    }
}

이 코드에서 longRunningTask() 메소드는 여전히 5초 동안 sleep 상태에 머무르지만, 이 작업이 완료되는 것을 기다리지 않고 즉시 CompletableFuture를 반환하므로 클라이언트는 더 빨리 응답을 받게 됩니다.

참고로 @Async를 사용하려면 Spring Boot 애플리케이션에 @EnableAsync를 선언해야 합니다. 보통 이는 메인 애플리케이션 클래스에서 설정하게 됩니다.

@SpringBootApplication
@EnableAsync
public class AsyncExampleApplication {
    public static void main(String[] args) {
        SpringApplication.run(AsyncExampleApplication.class, args);
    }
}

```
### CompletableFuture<?>
CompletableFuture<String>는 비동기적으로 실행되는 연산의 결과를 담는 클래스입니다. CompletableFuture는 Java 8에서 소개된 Future 인터페이스의 확장으로, 연산이 완료되었는지 확인하고, 결과를 검색하고, 연산이 완료될 때까지 대기하는 등의 작업을 할 수 있습니다.

CompletableFuture<String>의 경우, 이는 연산의 결과가 String 타입이라는 것을 의미합니다. 연산이 아직 완료되지 않았다면, CompletableFuture를 통해 결과를 얻으려고 시도하면 해당 연산이 완료될 때까지 대기하게 됩니다.

또한 CompletableFuture는 연산이 완료되면 실행될 다른 연산을 체인 형식으로 연결할 수 있게 해주는 여러 메소드를 제공합니다. 이런 메소드에는 thenApply(), thenAccept(), thenCompose(), thenCombine() 등이 있습니다.

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    // Long running task
    try {
        Thread.sleep(5000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return "Task completed";
});

// Do other things while the task is running...

try {
    String result = future.get();  // This will block until the task is complete
    System.out.println(result);
} catch (InterruptedException | ExecutionException e) {
    e.printStackTrace();
}

이 예제에서 CompletableFuture.supplyAsync()를 사용하여 긴 작업을 비동기적으로 실행하고, future.get()을 호출하여 작업이 완료될 때까지 기다린 후 결과를 가져옵니다.

```

## MSA(마이크로서비스 아키텍처) 각 도메인 통신시 Restful방식, 이벤트드리븐 방식 장단점 과 상황에 따라 적합한 방식 선택방법

 마이크로서비스 아키텍처에서 서비스 간 통신을 위해 RESTful API를 사용하거나 이벤트 드리븐 방식을 사용할 수 있습니다. 두 가지 방식은 각각 장단점을 가지고 있으며, 특정 상황과 요구사항에 따라 적합한 방식을 선택하는 것이 중요합니다.

### RESTful API
 ```text
RESTful API는 일반적으로 요청/응답 모델을 기반으로 합니다. 클라이언트는 서버에 특정 작업을 수행하도록 요청하고, 서버는 해당 작업을 수행한 후 결과를 클라이언트에게 반환합니다.

장점:

구조가 단순하고 이해하기 쉽습니다.
HTTP와 같은 기존의 표준 프로토콜을 사용하므로, 기존 인프라와 호환성이 좋습니다.
동기식 통신을 요구하는 작업에 적합합니다.
단점:

서비스 간 결합도가 높아질 수 있습니다. 즉, 한 서비스가 다른 서비스의 API에 의존하게 되므로, 해당 API가 변경되면 의존하는 서비스도 변경해야 할 수 있습니다.
대량의 데이터를 실시간으로 처리해야 하는 상황에서는 성능이 떨어질 수 있습니다.
 ```
### 이벤트 드리븐 아키텍처
```text
이벤트 드리븐 아키텍처는 서비스가 이벤트를 발행하고, 다른 서비스가 해당 이벤트를 구독하여 반응하는 방식입니다. 이벤트는 일반적으로 메시지 큐나 이벤트 버스를 통해 전달됩니다.

장점:

서비스 간 결합도가 낮습니다. 서비스는 이벤트의 발행만 신경 쓰며, 이벤트를 어떻게 처리하는지는 구독하는 서비스에게 맡깁니다.
비동기식 통신을 가능하게 하므로, 실시간 데이터 처리나 대량의 데이터 처리에 적합합니다.
장애 격리가 가능합니다. 한 서비스가 실패하더라도 이벤트는 큐에 저장되어 있으므로, 장애가 해결된 후에 처리할 수 있습니다.
단점:

- 이벤트의 전달과 처리가 비동기적으로 이루어지므로, 전체 시스템의 동작을 추적하거나 디버깅하는 것이 어려울 수 있습니다.

- 이벤트의 순서를 보장하기 어려울 수 있습니다.

- 설계와 개발이 복잡할 수 있습니다: 이벤트를 처리하는 로직이 분산되어 있기 때문에, 전체 시스템의 흐름을 이해하고 관리하는 것이 어렵습니다. 또한, 이벤트의 순서나 타이밍에 대한 이슈를 처리해야 할 수도 있습니다.

- 메시지 전달의 신뢰성을 보장하기 위한 추가적인 구성이 필요합니다: 서비스가 이벤트를 손실하지 않고 정확하게 전달받는 것을 보장하기 위해, 메시지 큐나 이벤트 버스 등의 컴포넌트가 필요합니다. 이러한 컴포넌트의 관리와 운영은 추가적인 복잡성을 야기할 수 있습니다.

REST 방식과 이벤트 드리븐 방식 간의 선택은 여러 요인을 고려해야 합니다. 예를 들어, 서비스 간의 결합도를 최소화하고 대량의 데이터를 실시간으로 처리해야 하는 경우에는 이벤트 드리븐 방식이 적합할 수 있습니다. 반면, 구조가 간단하고 이해하기 쉬운 방식을 선호하거나, 서비스 간의 동기식 통신이 필요한 경우에는 RESTful API를 사용하는 것이 좋을 수 있습니다. 또한, 두 방식을 적절하게 혼합하여 사용하는 것도 가능합니다.

```
### 이벤트 드리븐 방식 아키텍처
이벤트 생산자 (Event Producers): 이벤트를 생성하고 이벤트 버스에 전송합니다.

이벤트 버스 (Event Bus): 생성된 이벤트를 전달받아, 구독하고 있는 이벤트 소비자에게 전송하는 역할을 합니다. 이벤트 버스는 종종 메시징 시스템을 기반으로 구현되며, 대표적으로 RabbitMQ, Kafka 등이 있습니다.

이벤트 소비자 (Event Consumers): 이벤트 버스로부터 이벤트를 전달받아 처리합니다. 이벤트 소비자는 이벤트 버스에 필요한 이벤트를 구독하고 있습니다.
```text
  +----------------+    +------------+    +----------------+
  | Event Producers|    | Event Bus  |    | Event Consumers|
  |                |    |            |    |                |
  | - Create Events|    | - Route    |    | - Process      |
  | - Send to Bus  |    |   Events   |    |   Events       |
  +----------------+    +------------+    +----------------+
            |                 ^                |
            |                 |                |
            +-----------------+----------------+
                              |
                      All events flow through
                           the Event Bus

이러한 아키텍처의 주요한 장점은, 생산자와 소비자가 서로 독립적으로 동작할 수 있다는 것입니다. 즉, 생산자는 이벤트를 생성하고 전달하는 것에만 집중하고, 소비자는 필요한 이벤트를 처리하는 것에만 집중할 수 있습니다. 또한, 이벤트 버스를 통해 이벤트가 흐르는 방식은 시스템 전체에 걸쳐 동일하게 적용되므로, 개별 서비스는 각자의 로직에만 집중하면 됩니다. 이는 시스템의 확장성과 유지보수성을 높이는 데 도움이 됩니다.
```
### 이벤트에 전달되는 Queue 전달되는 구조
```text
이벤트 식별자 (Event ID): 각 이벤트를 유일하게 식별할 수 있는 ID가 필요합니다. 이 ID를 통해 이벤트를 추적하거나 문제를 진단하는 데 도움이 될 수 있습니다.

이벤트 유형 (Event Type): 이벤트의 종류를 나타내는 필드가 있으면, 소비자가 이벤트를 어떻게 처리할지 결정하는 데 도움이 됩니다.

이벤트 생성 시간 (Event Timestamp): 이벤트가 언제 생성되었는지 나타내는 시간 필드가 있으면, 이벤트의 순서를 파악하거나 이벤트를 언제 처리해야 하는지 결정하는 데 도움이 될 수 있습니다.

이벤트 페이로드 (Event Payload): 이벤트와 관련된 실제 데이터를 포함하는 필드입니다. 이 부분은 이벤트의 종류에 따라 매우 다양하게 변할 수 있습니다.

용량: 큐의 용량을 초과하지 않도록 이벤트의 크기를 적절히 관리해야 합니다. 이벤트가 너무 큰 경우, 이를 적절한 크기로 분할하거나 필요하지 않은 데이터를 제거해야 할 수도 있습니다.

구조: 이벤트 데이터는 일관된 구조를 가져야 합니다. 이를 위해 스키마를 정의하고 이를 준수하는 것이 중요합니다. 예를 들어, JSON, Avro, Protobuf 등의 데이터 형식을 사용할 수 있습니다.

직렬화/역직렬화: 이벤트 데이터는 네트워크를 통해 전송되기 전에 바이트 형태로 직렬화되어야 하며, 소비자에서는 이를 다시 원래의 형태로 역직렬화해야 합니다. 이 과정에서 발생할 수 있는 오류나 부하를 최소화하려면, 적절한 직렬화/역직렬화 방법을 선택해야 합니다.

에러 핸들링: 이벤트 전송이 실패한 경우, 적절한 재시도 메커니즘을 가지고 있어야 합니다. 또한, 잘못된 이벤트 데이터를 어떻게 처리할지에 대한 전략이 필요합니다.
```



## GC JAVA 1.0, 1.4, 1.7, 11 
```text
자바의 가비지 컬렉션(GC)은 메모리 관리의 중요한 부분으로, 더 이상 사용되지 않는 객체를 자동으로 정리합니다. 자바의 버전마다 GC의 작동 방식에는 몇 가지 차이점이 있습니다. 이는 여러 GC 알고리즘이 있고, 자바의 버전에 따라 이들 중 어떤 것을 기본값으로 사용하거나 사용할 수 있는지가 다르기 때문입니다.

(JDK 1.0 이후 사용 가능):
Serial GC: 이 방식은 가장 기본적인 GC입니다. 한 번에 하나의 일만 처리하는 단일 스레드로 동작합니다. 그래서 작은 애플리케이션에 적합하나, 큰 시스템이나 여러 개의 프로세서를 가진 시스템에서는 성능이 좋지 않을 수 있습니다.

(JDK 1.4 이후 사용 가능):
Parallel GC: 이 방식은 여러 개의 스레드를 사용하여 GC 작업을 동시에 처리합니다. 따라서 더 빠르게 메모리를 정리할 수 있지만, GC 작업이 진행되는 동안 애플리케이션이 일시 중단되는 'stop-the-world' 상황이 발생합니다.

Concurrent Mark Sweep (CMS) GC (JDK 1.5 이후 사용 가능):
Concurrent Mark Sweep (CMS) GC: 이 방식은 GC 작업을 애플리케이션의 동작과 병행해서 처리하여 'stop-the-world' 상황을 최소화하려고 합니다. 하지만 이 방식도 메모리를 불규칙하게 사용하다 보니 메모리가 '조각난' 상태가 될 수 있습니다.

G1 GC (JDK 1.7 이후 사용 가능, JDK 9부터 기본 GC):
G1 GC: 이 방식은 CMS에서 발생하는 메모리 '조각남' 문제를 해결하기 위해 만들어졌습니다. 메모리를 여러 개의 작은 부분으로 나누고, 각 부분을 독립적으로 관리하여 메모리를 효율적으로 사용합니다.

ZGC (JDK 11 이후 사용 가능):
ZGC: 이 방식은 거의 모든 GC 작업을 애플리케이션 동작과 동시에 처리하여 'stop-the-world' 상황을 거의 없애려고 합니다. 큰 메모리를 가진 시스템에서도 일관된 낮은 지연시간을 유지할 수 있습니다.


```

## JVM이란 ?
```java
Java Virtual Machine (JVM)은 자바 프로그램을 실행하는 가상 머신입니다. 컴파일된 자바 코드는 JVM에서 실행됩니다. JVM은 명령어를 읽고 해석하며, 실행 중에 메모리 할당과 해제, 가비지 수집 등을 수행합니다. 이렇게 함으로써, 자바 프로그램은 운영체제나 하드웨어에 의존하지 않고, 어디서든 실행될 수 있습니다.

JVM (Java Virtual Machine)은 Java 프로그램을 실행하는 데 사용되는 가상 머신입니다. Java의 핵심 철학 중 하나는 "한 번 작성하고, 어디에서나 실행하라(Write Once, Run Anywhere)"이며, 이를 가능하게 하는 기술이 바로 JVM입니다. JVM은 Java 프로그램을 실행하기 위해 필요한 바이트코드 인터프리터와 런타임 환경을 제공합니다.

JVM의 주요 기능은 다음과 같습니다:

1. **바이트코드 로딩**: JVM은 Java 컴파일러가 생성한 .class 파일의 바이트코드를 로드합니다. 바이트코드는 기계어가 아닌, 플랫폼에 독립적인 중간 형식입니다.
2. **바이트코드 검증**: 로드된 바이트코드가 올바른지 확인하고 안전한지 검증합니다. 검증 과정에서 문제가 발견되면, JVM은 프로그램 실행을 중지합니다.
3. **바이트코드 인터프리팅**: JVM은 바이트코드를 기계어로 변환하고, 실제 시스템에서 실행합니다. 이 과정에서 JIT(Just-In-Time) 컴파일러를 사용해 자주 사용되는 코드를 최적화하여 빠르게 실행할 수 있도록 합니다.
4. **메모리 관리**: JVM은 Java 프로그램의 메모리 관리를 담당합니다. JVM은 메모리 할당 및 가비지 컬렉션을 수행하여 사용되지 않는 메모리를 회수하고, 메모리 누수를 방지합니다.
5. **런타임 환경**: JVM은 Java 프로그램이 실행되는 동안 필요한 라이브러리, 클래스 로더, 스레드 관리, 보안 기능 등을 제공합니다.

JVM은 여러 플랫폼에서 동일한 바이트코드를 실행할 수 있도록 설계되어 있습니다. 이는 Java 프로그램이 플랫폼 독립적으로 작동하게 하며, 개발자가 다양한 환경에서 동일한 코드를 실행할 수 있도록 지원합니다. 이러한 이유로 Java는 웹 서버, 모바일 애플리케이션, 기업용 소프트웨어 등 다양한 분야에서 널리 사용되고 있습니다.
```

## 웜업(Warm up)
서버에서 발생하게되는 업데이트 또는 재시작에 불안정상태에서 높아지는 트래픽에 대한 부분을 해소하기위한 Warm up 방법

```java
ava JIT Compiler:
Java JIT(Just-In-Time) 컴파일러는 Java의 성능을 향상시키는 핵심 기술 중 하나입니다. Java 코드는 먼저 바이트코드로 변환되며, 이 바이트코드는 JVM(Java Virtual Machine)에서 실행됩니다. JIT 컴파일러는 실행 시점에 바이트코드를 기계어로 변환(컴파일)하여 프로그램의 실행 속도를 높입니다. JIT 컴파일러는 빈번하게 사용되는 코드를 "핫 스팟"으로 식별하고 이러한 핫 스팟을 특히 최적화합니다.

Real Traffic API Warm Up:
API 웜업은 서버가 최적의 성능을 발휘하기 전에 일정량의 트래픽을 받도록 하는 프로세스를 말합니다. 이는 JVM이 JIT 최적화를 완료하는 데 시간이 필요하기 때문입니다. 실제 트래픽으로 API를 웜업하면, 서버가 트래픽에 대응하는 능력을 개선하고 응답 시간을 줄일 수 있습니다.

JIT C2 Optimization:
C2는 Java의 JIT 컴파일러인 HotSpot VM의 일부입니다. C2 컴파일러는 서버 애플리케이션의 성능을 크게 향상시킬 수 있는 고급 최적화를 수행합니다. 이는 코드 인라인화, 루프 언롤링 및 데드 코드 제거와 같은 기능을 포함합니다.

```

### SpringBoot WAS에서 회원 도메인 서비스의 웜업:

웜업은 일반적으로 서버가 충분한 트래픽을 받아 JIT 컴파일이 이루어질 수 있도록 하는 것을 의미합니다. 이는 서버가 최적의 성능을 발휘하도록 돕습니다. 이를 위해 로드 테스트나 스트레스 테스트 도구를 사용하여 일정량의 가상 트래픽을 생성하고 이를 회원 도메인 서비스에 적용할 수 있습니다.  

SpringBoot 웹 애플리케이션에서는, 애플리케이션 시작 시점에 주요 API를 호출하여 서비스를 웜업하는 방법을 고려할 수 있습니다. 예를 들어, CommandLineRunner 또는 ApplicationRunner 인터페이스를 구현하는 Spring Bean을 생성하고, 이를 사용하여 애플리케이션 시작 시점에 웜업 API를 호출할 수 있습니다.  

효과적인 웜업 전략입니다. 실제 사용자의 행동 패턴과 가장 비슷한 부하를 생성하는 것이 가장 이상적입니다. 이를 위해 다음과 같은 단계를 따를 수 있습니다.  
```java
### 트래픽 분석 : 
실제 사용자의 행동 패턴을 이해하는 것이 중요합니다. 어떤 API가 가장 많이 호출되는지, 어떤 시간대에 트래픽이 가장 많은지 등을 분석하십시오. 이 정보를 사용하여 웜업 전략을 계획할 수 있습니다.  
### 웜업 스크립트 작성 : 
실제 트래픽 패턴을 반영하는 웜업 스크립트를 작성합니다. 이 스크립트는 주요 API를 호출하고, 필요한 데이터를 생성하며, 서버가 실제 사용자 부하를 처리하는 능력을 향상시킵니다.  
### 웜업 실행 : 
서버가 시작하거나 배포 후에 웜업 스크립트를 실행합니다. 이렇게 하면 JIT 컴파일러가 필요한 최적화를 수행할 수 있게 됩니다.  
### 성능 모니터링 : 
웜업이 효과적인지 확인하기 위해 서버의 성능을 모니터링합니다. 응답 시간, 처리량, 에러율 등을 확인하고, 필요한 경우 웜업 전략을 조정합니다.  
```
이러한 방법으로 SpringBoot WAS에서 회원 도메인 서비스를 웜업하는 것은 서버의 성능과 안정성을 향상시키는 데 중요한 역할을 합니다. 이를 통해 사용자는 더 빠르고 안정적인 서비스를 경험할 수 있습니다.

예를들어 회원 서비스 도메인 에대한 Was에 대해서 warmup 을 진행한다면 코드는 아래와같습니다.
SpringBoot에서 웜업 스크립트를 작성하려면 먼저 웜업 시킬 API의 동작을 이해하고, API 호출을 위한 적절한 요청 데이터를 준비해야 합니다. 회원 조회, 회원 가입, 회원 로그인과 같은 API를 웜업하는 경우, 각 API 호출에 필요한 요청을 생성하고, 이를 웜업 스크립트로 구성할 수 있습니다.

웜업 스크립트는 프로그래밍 언어 또는 특정 툴을 사용해 작성할 수 있습니다. 또한 스프링부트의 경우 CommandLineRunner나 ApplicationRunner를 사용해 웜업 로직을 구현할 수도 있습니다.

다음은 회원 가입 API를 웜업하는 Java 코드의 간략한 예시입니다:
```java
@Bean
public CommandLineRunner warmup(UserService userService) {
    return args -> {
        for (int i = 0; i < 100; i++) {
            UserDto userDto = new UserDto();
            userDto.setUsername("user" + i);
            userDto.setPassword("password");
            userService.signUp(userDto);
        }
    };
}

```
## JVM 에서 java -> 핫스팟 -> JIT 
Java 코드가 JVM에서 처리되는 과정은 다음과 같습니다.

Java 컴파일러(javac)가 Java 소스 코드(.java 파일)를 바이트코드(.class 파일)로 컴파일합니다. 바이트코드는 플랫폼에 독립적인 중간 코드입니다.

JVM이 바이트코드를 로드하고 인터프리터가 한 줄씩 실행합니다.

JVM은 프로그램이 실행되는 동안 어떤 코드가 가장 자주 실행되는지 살펴봅니다. 이런 코드를 "핫 스팟"이라고 부릅니다.

JIT 컴파일러는 이러한 핫 스팟을 기계 코드로 컴파일하여 프로그램의 성능을 향상시킵니다.

JIT 컴파일러는 동적으로 컴파일된 코드를 JVM에 캐시하여, 같은 코드가 다시 실행될 때 빠르게 접근할 수 있도록 합니다.

```java
public class Main {
    public static void main(String[] args) {
        for (int i = 0; i < 10000; i++) {
            hotMethod(i);
        }
    }

    public static void hotMethod(int i) {
        System.out.println("This is a hot method: " + i);
    }
}

```
위의 hotMethod는 반복문에 의해 10000번 호출되므로 JVM에 의해 핫 스팟으로 식별될 것입니다. 따라서 JIT 컴파일러는 이 메소드를 기계 코드로 컴파일하고, 이후 호출에서는 컴파일된 코드를 사용하여 실행 속도를 향상시킬 것입니다. 이것이 Java JIT 컴파일러가 동작하는 기본적인 원리입니다.

이 과정을 도식화하면 다음과 같습니다:
```java
Java Source Code (.java)
       |
       V
Java Compiler (javac)
       |
       V
Bytecode (.class)
       |
       V
Java Virtual Machine (JVM)
       |
       V
Interpreter (Executes bytecode line by line)
       |
       V
Hot Spots Identified (Frequently executed code)
       |
       V
Just-In-Time (JIT) Compiler
       |
       V
Machine Code (Optimized for execution)

```


## java버전에 대한 정리 변경점
```java

Java 8
람다 표현식(Lambda Expressions): 익명 함수를 생성하기 위한 표현식. 이를 통해 자바 코드를 더욱 간결하게 작성할 수 있게 되었습니다.
스트림 API(Stream API): 컬렉션을 처리하는 데 유용한 도구로, 병렬 처리와 함수형 프로그래밍 스타일이 가능합니다.
Optional 클래스: NullPointerException을 방지하기 위한 클래스입니다. 이를 통해 값의 존재나 부재를 표현할 수 있습니다.
날짜 및 시간 API(DateTime API): 기존의 java.util.Date 클래스의 문제점을 해결하기 위한 새로운 날짜와 시간 API를 도입하였습니다.

Java 11
HTTP Client API: 이전 버전의 HttpURLConnection을 대체하는 새로운 HTTP 클라이언트 API를 제공합니다.
Epsilon 가비지 컬렉터: 메모리 회수를 수행하지 않는 가비지 컬렉터로, 성능 테스트나 메모리 관리에 대한 연구에 유용합니다.
'var' 키워드: 로컬 변수 선언 시 자료형을 명시하지 않아도 되게 하는 'var' 키워드를 도입하였습니다.
String 클래스의 추가 메서드: String 클래스에 lines(), repeat(), strip(), isBlank() 등의 메서드가 추가되었습니다.

Java 11은 2018년에 출시된 Long-Term Support (LTS) 버전으로, 여러 중요한 특징과 변경사항을 가지고 있습니다. 이 중 일부를 다음과 같이 요약할 수 있습니다:
LTS(Long Term Support) 버전: Java 11은 Oracle에서 공식적으로 지원하는 두 번째 장기 지원 버전입니다. 이는 주요 업데이트와 보안 패치를 오랜 기간 동안 받을 수 있다는 것을 의미합니다.
Local-Variable Syntax for Lambda Parameters: Java 11에서는 람다 파라미터에 대한 로컬 변수 문법을 도입하였습니다. 이를 통해 람다 식에서도 var 키워드를 사용할 수 있게 되었습니다.
HTTP Client API: Java 11에서는 새로운 HTTP 클라이언트 API를 추가하였습니다. 이 API는 HTTP/2 지원, 웹소켓 프로그래밍 지원, 비동기 프로그래밍 모델 등을 제공합니다.
String API의 추가: 여러 유용한 메서드가 String 클래스에 추가되었습니다. 예를 들어, strip(), repeat(), isBlank(), lines() 등이 있습니다.
JShell: JShell은 Java 11에서 도입된 대화형 Java 셸로, 코드 스니펫을 빠르게 테스트하고 실행할 수 있게 합니다.
Flight Recorder: Java Flight Recorder는 JVM의 성능 문제를 진단하는 도구로, 이전에는 상업용 라이선스로만 제공되었으나 Java 11부터는 오픈소스로 제공되었습니다.
Z Garbage Collector(ZGC): ZGC는 Java 11에서 도입된 새로운 가비지 컬렉터로, 대량의 메모리(테라바이트 이상)를 효과적으로 관리하며, GC 일시정지 시간을 최소화합니다.
Removed APIs and Features: Java 11에서는 일부 API와 기능이 제거되었습니다. 예를 들어, Java EE 및 CORBA 모듈과 JavaFX가 JDK에서 분리되었습니다. 또한, Nashorn JavaScript 엔진이 더 이상 유지 보수되지 않습니다.

Java 17
패턴 매칭 for instanceof: 'instanceof' 연산자와 함께 패턴 매칭을 도입하여, 타입 검사와 타입 캐스팅을 보다 간결하게 수행할 수 있습니다.
Sealed Classes(봉인된 클래스): 클래스나 인터페이스가 어떤 다른 클래스나 인터페이스에 의해 상속되거나 구현될 수 있는지 제한하는 기능입니다.
LTS(Long Term Support) 버전: 자바 17은 LTS 버전이며, 이는 오랜 기간 동안 지원받을 수 있다는 것을 의미합니다.

```

## String 클래스
```java
자바 8 이전에는 String 클래스에 이미 많은 메소드가 있었습니다. 
예를 들어, 문자열의 길이를 구하는 length(), 특정 인덱스의 문자를 구하는 charAt(), 문자열을 부분 문자열로 분할하는 substring(), 문자열을 결합하는 concat(), 문자열에서 특정 문자나 문자열을 찾는 indexOf()와 contains(), 문자열을 대/소문자로 변환하는 toUpperCase()와 toLowerCase(), 문자열을 비교하는 equals(), equalsIgnoreCase(), startsWith(), endsWith(), compareTo(), 문자열의 공백을 제거하는 trim() 등이 있습니다.

그러나 자바 8에서는 이러한 기능 외에도 몇 가지 새로운 메소드가 추가되었습니다:

join(): 여러 문자열을 결합합니다. 첫 번째 인수는 구분자로 사용되고, 이후의 인수들은 결합될 문자열입니다.
chars(): 문자열을 IntStream으로 변환합니다. 이를 통해 문자열의 각 문자를 스트림에서 사용할 수 있게 됩니다.
codePoints(): 문자열을 IntStream으로 변환하지만, 이 메소드는 유니코드 코드 포인트를 반환합니다.

그리고 자바 11에서 추가된 몇 가지 메소드는 다음과 같습니다:
isBlank(): 문자열이 비어 있거나 공백 문자만 포함하는지 검사합니다.
strip(), stripLeading(), stripTrailing(): 문자열의 앞, 뒤, 또는 양쪽 끝에 있는 공백을 제거합니다. trim() 메소드와 유사하지만, 유니코드 공백 문자도 처리합니다.
lines(): 문자열을 스트림의 각 줄로 분할합니다.
repeat(int): 문자열을 주어진 횟수만큼 반복합니다.
이러한 메소드들을 활용하면 문자열 처리 작업을 보다 효과적으로 수행할 수 있습니다.
```

## 함수형 프로그래밍
```java
함수형 프로그래밍이란 무엇인가요?: 
이 질문은 면접자가 함수형 프로그래밍의 기본적인 개념에 대해 이해하고 있는지 확인하는데 사용됩니다. 함수형 프로그래밍은 프로그래밍 패러다임의 하나로, 계산을 일련의 함수로 보고 상태 및 변경 가능한 데이터를 피하는 것을 중점으로 둡니다.

함수형 프로그래밍의 장점과 단점은 무엇인가요?: 
이 질문은 면접자가 함수형 프로그래밍을 사용하는 이유, 그리고 그것의 한계에 대해 이해하고 있는지 확인하는 데 사용됩니다.

순수 함수(pure function)란 무엇이며, 왜 중요한가요?: 
순수 함수는 같은 입력에 대해 항상 같은 출력을 반환하며, 부수 효과(side effects)가 없는 함수를 말합니다. 이러한 특성 덕분에 함수의 동작을 예측하기 쉽고, 디버깅을 용이하게 만듭니다.

고차 함수(higher-order function)란 무엇인가요?: 
고차 함수는 다른 함수를 인자로 받거나, 함수를 결과로 반환하는 함수를 말합니다. 이 개념은 함수형 프로그래밍에서 중요한 역할을 합니다.

불변성(immutability)이 중요한 이유는 무엇인가요?: 
함수형 프로그래밍에서는 상태 변경을 피하려고 합니다. 이것이 불변성의 중요성을 뒷받침합니다. 불변성은 데이터의 안정성을 보장하고, 다중 스레딩 환경에서의 문제를 방지할 수 있습니다.

리스트를 불변으로 만들고, map, filter, reduce와 같은 함수형 메소드를 사용하는 예제 코드를 작성해 보세요.

모나드(monad)란 무엇인가요? 그리고 그것이 프로그래밍에 어떻게 도움이 되나요?: 이 질문은 면접자가 함수형 프로그래밍의 고급 개념인 모나드에 대해 이해하고 있는지 확인하는 데 사용됩니다.

함수형 프로그래밍에서 부수 효과(side effect)란 무엇인가요? 그리고 왜 피해야 하는가요?: 부수 효과란 함수가 외부 상태를 변경하거나 함수 실행이 외부 세계에 영향을 미치는 경우를 말합니다. 이러한 부수 효과는 함수의 예측 가능성을 저해하고, 버그를 발생시킬 수 있기 때문에 함수형 프로그래밍에서는 피하는 것이 좋습니다.

람다 함수(lambda function)란 무엇이며, 어떻게 사용하나요?: 람다 함수는 이름 없이 정의되고 실행되는 함수를 말합니다. 이는 함수를 인자로 전달하거나 결과로 반환하는 고차 함수에서 유용하게 사용됩니다.

재귀 함수의 사용에 대해 어떻게 생각하나요? 그리고 재귀에 대한 자바스크립트의 지원은 어떤가요?: 재귀 함수는 함수가 자신을 호출하는 것을 말합니다. 함수형 프로그래밍에서는 반복문 대신 재귀를 사용하곤 합니다.

함수형 프로그래밍 패러다임을 사용하면서 어떤 어려움을 겪었나요? 그리고 어떻게 해결했나요?

커링(currying)이란 무엇인가요? 그리고 어떤 경우에 유용한가요?: 커링은 여러 인자를 받는 함수를 하나의 인자만 받는 함수로 나누는 기법을 말합니다. 이는 함수의 재사용성을 높이는 데 유용합니다.

함수형 프로그래밍 언어나 라이브러리를 사용하면서 어떤 프로젝트를 진행해본 경험이 있나요?

타입스크립트와 같은 정적 타입 시스템에서의 함수형 프로그래밍은 어떤 장점을 가질까요?

함수형 프로그래밍에서의 에러 처리 방식에 대해 설명해주세요.

Java 8부터는 스트림 API를 통해 함수형 프로그래밍 스타일을 지원하게 되었습니다. 이를 통해 map, filter, reduce와 같은 함수를 사용하여 불변성을 유지하면서 컬렉션을 효과적으로 처리할 수 있습니다.
 public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // map: 스트림의 각 요소에 함수를 적용한 결과로 새로운 스트림을 만듭니다.
        List<Integer> doubled = numbers.stream()
            .map(number -> number * 2)
            .collect(Collectors.toList());
        System.out.println(doubled); // [2, 4, 6, 8, 10]

        // filter: 주어진 함수의 테스트를 통과하는 모든 요소를 모아 새로운 스트림을 만듭니다.
        List<Integer> evens = numbers.stream()
            .filter(number -> number % 2 == 0)
            .collect(Collectors.toList());
        System.out.println(evens); // [2, 4]

        // reduce: 스트림의 각 요소에 함수를 적용하고 그 결과를 누적하여 하나의 값으로 만듭니다.
        int sum = numbers.stream()
            .reduce(0, (total, number) -> total + number);
        System.out.println(sum); // 15
    }
```
//-----------------------------------------------------------------------------------------
## Springboot 버전 변경점
```java
Spring Boot 2.0

이 버전에서는 Spring Framework 5.0와 Reactor를 통한 반응형 프로그래밍 지원이 주요 특징입니다.
또한, 이 버전에서는 Java 8 이상을 필요로 하며, Spring Data의 대폭 개선된 지원이 포함되어 있습니다.
기본 내장 서버로 Tomcat 8.5 이상, Jetty 9.4 이상, 그리고 Undertow 1.4.x 이상이 지원됩니다.

Spring Boot 2.0 부터는 보안 설정이 간소화되었으며 OAuth2 클라이언트 지원이 추가되었습니다.

Spring Boot 2.1

이 버전에서는 Spring 5.1을 기반으로 하며, 그에 따라 Java 11을 지원합니다.
또한, Micrometer를 통한 애플리케이션 메트릭스 수집이 강화되었습니다.
Spring Boot 2.2

이 버전에서는 Lazy Initialization, Java 13의 지원, 새로운 의존성 관리 플러그인 등이 추가되었습니다.

Spring Boot 2.3

이 버전에서는 Docker와 Kubernetes와의 통합이 강화되었습니다. 예를 들어, 레이어드 JAR를 통해 Docker 이미지 빌드를 최적화할 수 있게 되었습니다.
또한, Graceful Shutdown 기능이 추가되었습니다.

Spring Boot 2.4

이 버전에서는 Config Tree와 같은 새로운 구성 관련 기능이 도입되었습니다.
또한, Docker 이미지 빌드를 위한 Cloud Native Buildpacks 지원이 추가되었습니다.

Spring Boot 3.x
java17 이상필요
```
# 전반적인 스프링 질문정리
## 필터와 인터셉터 설명
```java
필터 (Filter):

필터는 서블릿 컨테이너 레벨에서 동작하며, HTTP 요청이 서블릿에 도달하기 전과 후에 수행할 작업을 정의합니다. 주로 인증, 인가, 로깅, 인코딩 설정 등과 같은 크로스 커팅(cross-cutting) concerns를 처리하는 데 사용됩니다. 스프링의 애플리케이션 컨텍스트의 기능에는 접근할 수 없습니다. 필터는 'javax.servlet.Filter' 인터페이스를 구현하여 만들며, doFilter 메서드를 통해 요청/응답을 처리합니다.

인터셉터 (Interceptor):

인터셉터는 스프링 MVC의 일부로, 컨트롤러의 동작 전후에 특정 작업을 수행합니다. 인터셉터는 스프링 애플리케이션 컨텍스트 내에서 동작하므로, 스프링의 보안 컨텍스트에 접근하거나, 스프링 빈을 주입받는 등의 스프링 특화 기능을 사용할 수 있습니다. 인터셉터는 'org.springframework.web.servlet.HandlerInterceptor' 인터페이스를 구현하여 만들며, preHandle, postHandle, afterCompletion 메서드를 통해 요청/응답을 처리합니다.

사용 시기:
필터는 모든 요청에 대해 일관된 처리가 필요할 때, 예를 들어 인증이나 로깅과 같은 경우에 사용됩니다.
인터셉터는 스프링의 애플리케이션 컨텍스트와의 상호작용이 필요할 때 또는 특정 컨트롤러에 대한 요청 전후에 작업을 수행할 때 사용됩니다.

이해를 돕기 위한 예를 들자면, HTTP 헤더에 기반한 인증 작업은 필터를 통해 처리할 수 있습니다. 반면, 스프링의 보안 컨텍스트에 접근하거나 스프링 빈을 사용하여 특정 컨트롤러의 요청을 처리하기 전후에 작업을 수행하려면 인터셉터를 사용하면 좋습니다.

```
## ControllerAdvice 설명
```java
스프링의 @ControllerAdvice 어노테이션은 여러 컨트롤러에 걸쳐 공통적으로 발생하는 문제를 한 곳에서 처리하는 것을 목표로 합니다. 이를 통해 코드 중복을 줄이고 유지 보수성을 향상시키며, 애플리케이션 전체에 걸쳐 일관된 동작을 제공할 수 있습니다.

@ControllerAdvice의 가장 주요 목적은 다음과 같이 요약할 수 있습니다:

전역 예외 처리: @ControllerAdvice와 @ExceptionHandler를 함께 사용하여 애플리케이션 전체에서 발생할 수 있는 특정 예외 유형을 처리할 수 있습니다. 이렇게 하면 각 컨트롤러에서 동일한 예외 처리 코드를 반복 작성하는 것을 피할 수 있습니다.

데이터 바인딩: @ControllerAdvice와 @InitBinder를 함께 사용하여 모든 컨트롤러에 걸쳐 공통적으로 사용되는 바인딩 설정을 정의할 수 있습니다. 예를 들어, 모든 날짜 필드에 동일한 형식을 적용하려는 경우에 이를 활용할 수 있습니다.

모델 어트리뷰트 추가: @ControllerAdvice와 @ModelAttribute를 함께 사용하여 모든 컨트롤러에 걸쳐 공통적으로 사용되는 모델 어트리뷰트를 정의할 수 있습니다. 이렇게 하면 각 뷰에서 동일한 데이터에 쉽게 접근할 수 있습니다.

따라서, @ControllerAdvice를 사용하는 주요 목적은 코드 중복을 줄이고 일관된 동작을 제공하는 것입니다. 이를 통해 애플리케이션의 유지 보수성과 확장성을 향상시킬 수 있습니다.
```
## AOP 특징
```
스프링 AOP(Aspect-Oriented Programming)에 대해 면접에서 다루어질 수 있는 중요 포인트들은 다음과 같습니다:

AOP의 개념: AOP는 애플리케이션의 주 비즈니스 로직과는 별개의 횡단 관심사 (Cross-Cutting Concerns)를 분리하고 모듈화하는 방법입니다. 이를 통해 코드의 중복을 줄이고 가독성과 유지 보수성을 향상시킬 수 있습니다.

횡단 관심사의 예시: 횡단 관심사는 여러 클래스나 메서드에 걸쳐서 반복적으로 등장하는 코드 블록을 말합니다. 이는 로깅, 트랜잭션 관리, 보안, 캐싱 등이 될 수 있습니다.

Aspect, Pointcut, Advice의 이해: Aspect는 횡단 관심사를 모듈화한 코드 블록, Pointcut은 Aspect의 코드가 어떤 조인 포인트에서 실행될지를 결정하는 표현식, Advice는 실제로 Aspect의 코드가 언제 실행될지를 결정하는 것입니다.

스프링 AOP와 AspectJ의 차이점: 스프링 AOP는 프록시 기반의 AOP를 제공하며, 주로 런타임에 동작합니다. 이는 AspectJ와 같은 완전한 AOP 프레임워크보다는 덜 강력하지만, 대부분의 일반적인 경우에는 충분히 적합합니다.

AOP의 사용 사례: 실제 애플리케이션에서 AOP가 어떻게 사용될 수 있는지에 대한 사례를 준비하는 것이 좋습니다. 예를 들어, 모든 메서드 호출 전후에 로그를 출력하는 Aspect를 어떻게 구현할 수 있는지에 대해 설명할 수 있어야 합니다.

이러한 포인트들을 기반으로 AOP에 대한 깊은 이해를 보여주는 것이 중요합니다. 다양한 문맥에서 AOP를 어떻게 적용할 수 있는지, 그리고 이를 통해 어떤 이점을 얻을 수 있는지를 이해하는 것이 핵심입니다.
```
## AOP 필터에 차이
```java
필터(Filter)와 AOP(Aspect-Oriented Programming)는 모두 애플리케이션의 일정 부분에 걸쳐 공통적으로 적용되는 로직을 처리하는 데 사용됩니다. 그러나 그들의 사용 방법과 적용 범위에는 몇 가지 주요한 차이점이 있습니다.

적용 범위: 필터는 서블릿 컨테이너 레벨에서 작동하며, HTTP 요청과 응답에 대해 작동합니다. 이는 주로 요청과 응답의 전처리 및 후처리를 담당하며, 이는 인증, 로깅, 인코딩 설정 등과 같은 작업을 포함할 수 있습니다. 반면에, AOP는 애플리케이션의 특정 지점(조인 포인트라고 부름)에서 실행되는 로직을 캡슐화한 것으로, 이는 메서드 호출이나 예외 처리 등의 다양한 지점에서 작동할 수 있습니다.

적용 대상: 필터는 웹 요청과 응답에만 적용되지만, AOP는 애플리케이션의 모든 부분에 적용될 수 있습니다. 이는 필터가 웹 계층에서의 작업에 더 적합하다는 것을 의미하며, AOP는 비즈니스 로직, DAO 계층, 서비스 계층 등 애플리케이션의 다른 부분에서의 작업에 더 적합합니다.

유연성: AOP는 필터보다 더 세밀한 제어를 제공합니다. 예를 들어, AOP를 사용하면 메서드 호출 전, 후, 예외 발생 시 등 다양한 시점에 로직을 적용할 수 있습니다. 반면에, 필터는 요청이 처리되기 전과 후에만 로직을 적용할 수 있습니다.

따라서, 필터와 AOP는 비슷한 목적을 가지고 있지만, 그들의 사용 방법과 적용 범위는 다릅니다. 이 둘 중 어떤 것을 사용할지는 애플리케이션의 요구 사항과 문제의 복잡성에 따라 결정해야 합니다.
```


DI
WEB socket
Restful
webflux
feignclient


//-----------------------------------------------------------------------------------------
## JPA를 사용한 이유(중요) 
```java
RDBMS 테이블, 행, 열 에 대한것을 class method 객체지향적으로 가능하기때문에
개발자 관점에서 처리할수 있다는 장점이 있지만 그만큼 JPQL 이나 RDBMS에 호출되어 나가는 Query가 어떻게 내부적으로 동작하는지에 
대한 이해도가 있어야 많은 트래픽과 최적화를 구성할수 있는 쿼리 튜닝포인트를 해결해나갈수 있을것 같습니다.
 
```

### 1억 페이징 처리 커버링 인덱스

### 하이버네이트 1차캐쉬 2차캐쉬

### 더디체킹 
무분별한 더디체킹 확인 오브젝트라고해서 막쓰면 망
update, insert
실시간에선 효율적 더티체킹
일괄 처리는 QueryDSL

JPA+QueryDSL은 마술이 아니고 DB에 어떻게 쿼리가날라가는지 이해를해야
QueryDSL + DTO로 처리해야하는순간은 대량이다.

### 벌크 insert
벌크 인서트는 JDBC batch 로 처리하는것을 추천
Querydsl > Querydsl-jpa, Querydsl-sql

### flyway

### EntityQl 
JPA Entity 기반 Querydsl-SQL Qclass생성

### entity 할때 되도록 primitive type을 사용하기보다 wrapper class를 사용하는이유
퍼시스던트 레이어에 프록시 복제될때 레퍼클래스를 구성해야 복제되는부분에 리소스를 최소화할수있다고 


## Page객체 메모리릭
https://github.com/spring-projects/spring-boot/issues/19546

Spring JPA ORM 
spring data jpa -> Query DSL
복잡한 쿼리를 도와주는 동적쿼리 Where 

## 프로젝트에서 왜 JPA를 못썼나? 안쓴건가 못쓴건가

## JPA 정리 여러가지 이슈 케이스

### oneToone에서 n+1문제
```java
JPA에서 N+1 쿼리 문제는 연관된 엔티티를 조회하는 방식 때문에 발생합니다.

예를 들어, User와 Profile이 OneToOne 관계를 가지고 있다고 가정해 봅시다. 여기서 모든 User와 그에 해당하는 Profile을 가져오는 쿼리를 실행하면 N+1 문제가 발생할 수 있습니다.

먼저 모든 User를 조회하는 쿼리가 실행되며(SELECT * FROM User), 이는 "1"을 나타냅니다.
그 다음, 각 User에 대해 해당하는 Profile을 가져오는 쿼리가 실행되는데(SELECT * FROM Profile WHERE user_id = ?), 이는 각 User에 대해 별도의 SQL 쿼리를 실행하므로 "N"을 나타냅니다.
따라서 이런 식으로 쿼리가 실행되면 전체 쿼리 수는 조회하려는 User의 수(N)에 1을 더한 값(N+1)이 됩니다. 이를 N+1 문제라고 합니다.

이 문제를 해결하는 방법 중 하나는 "즉시 로딩(Eager Loading)" 또는 "조인 페치(Join Fetch)"를 사용하여 관련 엔티티를 한 번의 쿼리로 함께 가져오는 것입니다. 그러나 이 방법은 항상 최선의 해결책은 아닙니다. 모든 관련 엔티티를 항상 가져올 필요가 없는 경우, 불필요한 데이터를 로딩하게 되어 성능 저하를 일으킬 수 있습니다.

따라서 N+1 문제를 해결하는 가장 좋은 방법은 어플리케이션의 요구 사항과 데이터 접근 패턴을 이해하고, 적절한 쿼리 전략을 선택하는 것입니다.
```

### n+1 문제

```java
N+1 문제는 ORM(Object-Relational Mapping)을 사용하면서 발생할 수 있는 성능 문제 중 하나로, 주로 "지연 로딩" 전략을 사용할 때 발생합니다.

N+1 문제는 한 번의 쿼리로 가져올 수 있는 데이터를 여러 번의 쿼리로 가져와 성능이 저하되는 현상을 의미합니다. 이는 연관된 데이터를 조회할 때 각 데이터에 대해 추가로 쿼리가 실행되기 때문에 발생합니다.

예를 들어, 사용자(User)와 그들의 주문(Order) 사이에 OneToMany 관계가 있다고 가정해 봅시다. 만약 모든 사용자와 그들의 주문을 조회하려고 한다면, 먼저 사용자를 조회하는 쿼리가 실행될 것입니다. 이후 각 사용자마다 별도의 쿼리가 실행되어 주문을 조회하게 됩니다. 즉, 사용자 N명에 대해 N+1번의 쿼리가 실행되는 것이죠.

N+1 문제 해결 방법

- 즉시 로딩(Eager Loading) 사용: @ManyToOne 또는 @OneToOne 관계에 대해 즉시 로딩을 사용하면, 연관된 모든 데이터를 한 번의 쿼리로 가져올 수 있습니다. 그러나 이 방법은 필요하지 않은 데이터까지 모두 조회할 수 있어, 데이터 양이 많을 경우 성능 문제가 발생할 수 있습니다.

- JPQL 조인 FETCH 사용: JPQL의 JOIN FETCH를 사용하면, 원하는 연관된 데이터만 함께 조회할 수 있습니다. 이를 통해 불필요한 데이터 조회를 최소화하면서도 N+1 문제를 해결할 수 있습니다.

List<User> users = em.createQuery("SELECT u FROM User u JOIN FETCH u.orders", User.class).getResultList();

- @EntityGraph 사용: @EntityGraph 어노테이션을 사용하면, JPQL에서 별도로 FETCH JOIN을 명시하지 않아도 연관된 엔티티를 함께 조회할 수 있습니다. 이를 통해 N+1 문제를 해결할 수 있습니다.

@EntityGraph(attributePaths = { "orders" })
List<User> findAll();

이처럼 적절한 조회 전략을 사용하여 N+1 문제를 해결할 수 있습니다. 그러나 각 방법은 상황에 따라 장단점이 있으므로, 실제 적용시에는 성능 테스트 등을 통해 적절한 방법을 선택해야 합니다.
```

## 스프링 내부 핵심원리
Spring Core

## 객체지향 개발을 도와주는 도구 원칙 SOILD
DI, IOC 컨테이너

## Spring Web
HTTP 기반 설명

## spring MVC Servlet 
1편mvc 패턴 최신 mvc
2편 뷰템필릿 국제화 검증 세션 쿠키 파일업로드
3편 관계형 데이터베이스 스프링 db
기초학슴 JDBC, 컨넥션풀 데이터소스 트랜잭션 예외처리 DB접근기술
트랜잭션 QueryDSL 

스프링 고급
Springboot 편의기능
스프링 핵심 디자인패턴, 스프링로컬, 스프링 AOP 프록시
실무 모니터링 방법

## 테스트코드를 하는방법
정적분석

테스트코드

Lint코드 포맷팅



# JD정리 
```text
딜리버리플랫폼실 배민1, B마트 주문을 즉시 배달하기 위한 배달인프라 시스템을 기획, 개발합니다.

우리는 갑자기 주문수가 늘어나더라도 항상 치킨은 뜨겁게, 아이스아메리카노는 차갑게 고객에게 배달을 완료해야합니다.
이를 위한 견고한 시스템을 기획, 개발하고 있습니다.

이미 배달에 익숙한 전문 라이더는 물론이고, 여유 시간에 부담없이 일할 수 있는 배민커넥트까지
누구나 안전하게 배달하며 수익을 얻을 수 있는 환경을 만들기 위해 고민합니다.
기획자와 개발자가 한 팀으로 일하며, 고객에게 더 좋은 가치를 제공하기 위해 함께 고민하고 개선하며 성장하고 있습니다.

저희와 함께 새로운 도전과 성장을 할 백엔드 개발자를 찾습니다. 

배민커넥트 서비스를 만드는 딜리버리플랫폼실 조직 소개 내용은 '링크'를 통해 확인해주세요 👈  링크 클릭!

[업무내용]
주문 이후부터 배달이 완료되기까지의 프로세스를 기획자, 디자이너, QA분들과 함께 만들고 있습니다.
운영 효율, 사용성 향상을 위하여 다양한 요구사항을 분석하고 문제를 해결합니다.

- 배달특성에 따른 최적의 배차와 배달프로세스 과정을 관리하는 배차 & 배달플랫폼 개발
- 실시간 배달상황을 모니터링하고, 배달인프라 운영을 관리하는 관제플랫폼 개발
- 배민커넥트 지원, 정산, 성과 등 라이더 운영을 관리하는 라이더플랫폼 개발

[지원자격]
- 실무 경력 5년 이상 또는 그에 준하는 역량 보유자
- 다양한 문제에 다영한 접근법과 해법을 활용할 수 있는 백엔드 개발자
- 다음 기술에 익숙하신 분
- Java 8 이상
- Spring Framework, Spring boot, Spring Cloud, JPA, 기타 Java EE 기술
- AWS
- jUnit과 테스트코드 작성 라이브러리
- Git, Jira, Wiki 등의 협업 도구

[우대사항]
- Big Data 기반 애플리케이션 개발, ML 경험이나 관심이 있으신 분
- Reactive System 개발 경험이나 관심이 있으신 분
- Cloud Native Application 개발 경험이나 관심이 있으신 분
- 코드 유지보수성을 위해 꾸준하게 코드를 리팩터링하고 테스트 코드를 작성하시는 분
- 서비스 운영과 다양한 상황의 문제를 해결한 경험이 있으신 분
- 공개 클라우드 서비스(AWS)를 활용한 개발 및 운영 경험이 있으신 분
- 빌드/테스트/배포 자동화를 통한 CI/CD 경험이 있으신 분
- 대용량 실시간 애플리케이션/시스템 아키텍처 지식과 경험이 있으신 분
- Java 외 플랫폼에도 익숙하신 분

[개발환경]
- 주요 기술 : Java, Spring framework, JPA, Apache Kafka
- 업무 도구 : Gitlab, Slack, Jira, Confluence, Zeplin, Grafana, IntelliJ IDEA
- 코드 리뷰 : Gitlab MR, Upsource 사용 온라인 코드리뷰, 페어 프로그래밍 개발 진행
- 빌드, 배포, 테스트 : Jenkins, Simploy, JUnit

- 경력기술서 작성 Tip
- 자신의 기술력을 보여 줄 수 있도록 경험하신 업무 내용과 기술 스택을 구체적으로 기재해 주세요.
- 채용 직무의 업무내용과 자격요건에 부합하는 업무 경험과 성과가 잘 드러나도록 작성해 주시면 좋습니다. 
- Java, Spring framework 기반의 개발 경험을 적어주세요.
- 운영 중 발생한 이슈에 대해 문제 원인을 파악하고 해결한 사례가 있다면 어떤 기술을 사용하여 어떻게 개선했는지 구체적으로 적어주세요.
- 여러 시스템과 데이터 교환을 한 경험이 있다면 자세히 적어주세요.
- 리팩토링과 성능 개선의 경험을 적어주세요.
- 단위 테스트 작성에 대한 경험을 적어주세요.
```


# 참조링크
참조 : https://mungto.tistory.com/513

책읽기
리얼마이SQL
JPA